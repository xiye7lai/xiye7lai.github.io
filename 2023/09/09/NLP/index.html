<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="NLP速成"><meta name="keywords" content=""><meta name="author" content="ZJM"><meta name="copyright" content="ZJM"><meta name="theme-color" content="#ff1493"><title>NLP速成 | 翡——遥远的路程</title><link rel="shortcut icon" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#ff1493"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    let Yun = window.Yun || {};
    let CONFIG = {"root":"/","title":"山花与翡灯与酒坛","version":"0.5.2","anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"valine":{"el":"#valine-container","verify":false,"notify":false,"appId":"ulKw7RsdHXiwixLK9MXeLnPR-gzGzoHsz","appKey":"ldrm0TebHFFE6Vb3IiGnobUz","serverURLs":null,"placeholder":"Just go go","avatar":null,"meta":["nick","mail","link"],"pageSize":10,"lang":"zh-cn","visitor":false},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><script src="//at.alicdn.com/t/font_1140697_9juba7x0cw.js" async></script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js"></script><script class="meting-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle sidebar-toggle-fixed hty-icon-button"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><aside class="sidebar"><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc sidebar-nav-active hty-icon-button" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about" title="ZJM"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/xiye7lai/CDN/links/pr.jpg" alt="ZJM"></a><div class="site-author-name"><a href="/about/">ZJM</a></div><a class="site-name" href="/about/site.html">翡——遥远的路程</a><sub class="site-subtitle">zjm's blog</sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item site-state-posts"><a href="/archives" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">12</span></a></div><div class="site-state-item site-state-categories"><a href="/categories" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">4</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&amp;uin=1692823208&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/xiye7lai" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div></div><script defer src="/js/sidebar.js"></script><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NLP%E4%B8%8ELLM"><span class="toc-number">1.</span> <span class="toc-text">NLP与LLM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NLP-Natural-Language-Processing"><span class="toc-number">1.0.1.</span> <span class="toc-text">NLP(Natural Language Processing)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Pre-Norm%E4%B8%8EPost-Norm"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">Pre Norm与Post Norm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BN%E4%B8%8ELN"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">BN与LN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Word2Vec"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">Word2Vec</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RNN%EF%BC%88Recurrent-Neural-Network%EF%BC%89"><span class="toc-number">1.0.1.4.</span> <span class="toc-text">RNN（Recurrent Neural Network）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LSTM"><span class="toc-number">1.0.1.5.</span> <span class="toc-text">LSTM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Seq2Seq%EF%BC%88Attention%EF%BC%89"><span class="toc-number">1.0.1.6.</span> <span class="toc-text">Seq2Seq（Attention）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Transformer"><span class="toc-number">1.0.1.7.</span> <span class="toc-text">Transformer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BERT"><span class="toc-number">1.0.1.8.</span> <span class="toc-text">BERT</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LLM-Large-Language-Model"><span class="toc-number">1.0.2.</span> <span class="toc-text">LLM(Large Language Model)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GPT"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">GPT</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://www.xiye7lai.github.io/2023/09/09/NLP/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="ZJM"><meta itemprop="description" content="NLP速成"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="翡——遥远的路程"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">NLP速成</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2023-09-09 21:07:00" itemprop="dateCreated datePublished" datetime="2023-09-09T21:07:00+08:00">2023-09-09</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2023-09-10 23:29:50" itemprop="dateModified" datetime="2023-09-10T23:29:50+08:00">2023-09-10</time></div><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读次数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a class="category" href="/categories/AI/" itemprop="url" rel="index"><span itemprop="text">AI</span></a></span></span></div><div class="post-author"><span class="author-name">尘渊</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content post-markdown"><h1 id="NLP与LLM"><a href="#NLP与LLM" class="headerlink" title="NLP与LLM"></a>NLP与LLM</h1><h3 id="NLP-Natural-Language-Processing"><a href="#NLP-Natural-Language-Processing" class="headerlink" title="NLP(Natural Language Processing)"></a>NLP(Natural Language Processing)</h3><h4 id="Pre-Norm与Post-Norm"><a href="#Pre-Norm与Post-Norm" class="headerlink" title="Pre Norm与Post Norm"></a>Pre Norm与Post Norm</h4><ul>
<li><ul>
<li>Pre Norm（Norm and add）</li>
<li>Post Norm（Add and Norm）</li>
</ul>
</li>
<li><p>在同一训练设置下，同一设置之下，Pre Norm结构往往更容易训练，但最终效果通常不如Post Norm：</p>
</li>
<li><ul>
<li>Pre Norm更容易训练好理解，因为它的恒等路径更突出</li>
<li>Pre Norm的深度有“水分”！也就是说，一个L层的Pre Norm模型，其实际等效层数不如L层的Post Norm模型，而层数少了导致效果变差了。Post Norm每Norm一次就削弱一次恒等分支的权重，所以Post Norm反而是更突出残差分支的，因此Post Norm中的层数更加“足秤”，一旦训练好之后效果更优。</li>
</ul>
</li>
<li><p>Post Norm的结构迁移性能更加好，也就是说在Pretraining中，Pre Norm和Post Norm都能做到大致相同的结果，但是Post Norm的Finetune效果明显更好</p>
</li>
</ul>
<h4 id="BN与LN"><a href="#BN与LN" class="headerlink" title="BN与LN"></a>BN与LN</h4><ul>
<li><p>BN 与 LN 定义：Batch Normalization 是对这批样本的同一维度特征做规范化处理， Layer Normalization 是对这单个样本的所有维度特征做规范化处理</p>
</li>
<li><ul>
<li><p>区别：</p>
</li>
<li><ul>
<li>LN中同层神经元输入拥有相同的均值和方差，不同的输入样本有不同的均值和方差；BN中则针对不同神经元输入计算均值和方差，同一个batch中的输入拥有相同的均值和方差</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><p>为什么 NLP 使用 LN 而不是 BN？</p>
</li>
<li><ul>
<li>LN 不依赖于 batch 的大小和输入 sequence 的长度，因此可以用于 batchsize 为 1 和 RNN 中 sequence 的 normalize 操作</li>
<li>BN 不适用于 batch 中 sequence 长度不一样的情况，有的靠后面的特征的均值和方差不能估算；另外 BN 在 MLP 中的应用对每个特征在 batch 维度求均值方差，比如身高、体重等特征，但是在 NLP 中对应的是每一个单词，但是每个单词表达的特征是不一样的</li>
<li>如果特征依赖于不同样本间的统计参数（比如 CV 领域），那么 BN 更有效(它抹杀了不同特征之间的大小关系，但是保留了不同样本间的大小关系)；NLP 领域 LN 更合适（抹杀了不同样本间的大小关系，但是保留了一个样本内不同特征之间的大小关系），因为对于 NLP 或序列任务来说，一条样本的不同特征其实就是时序上字符取值的变化，样本内的特征关系是非常紧密的</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>相同点：标准化技术目的是让每一层的分布稳定下来，让后面的层可以在前面层的基础上安心学习，加快模型收敛</li>
</ul>
</li>
</ul>
<h4 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h4><p>word2vec是一种将word转为向量的方法，其包含两种算法，分别是skip-gram和CBOW，它们的最大区别是skip-gram是通过中心词去预测中心词周围的词，而CBOW是通过周围的词去预测中心词。</p>
<p>one-hot编码在大量数据情况下会出现维度灾难，会导致数据非常稀疏（0多1少），于是采用<strong>分布式表示</strong>（通过训练，将每个词都映射到一个较Pre的词向量上）维度中的数字已经不是1和0了，而是一些其他的浮点数。</p>
<p>这种将高维度的词表示转换为低维度的词表示的方法，我们称之为<strong>词嵌入（word embedding）</strong>。</p>
<p>分布式表示的词向量含有词语上下文信息（例：King-Man+Woman=Queen），<strong>CBOW</strong>就是通过当前中心词的上下文单词信息预测当前中心词。</p>
<p><img src="D:\github\CDN\bg\pic\cbow.png" loading="lazy"></p>
<p>通过一次周围词矩阵即可获得目标向量，常用词向量维度D为300。</p>
<p><strong>skim-gram</strong>模型如下</p>
<p><img src="D:\github\CDN\bg\pic\skipgram.png" alt="skipgram" loading="lazy"></p>
<p>在训练结束后，对于词典中任一索引为i的词，我们都会得到两组词向量，在自然语言处理应用中，一般使用skip-gram模型的中心词向量作为词的表征向量。</p>
<p><strong>词嵌入</strong>：句子中每个单词以Onehot形式作为输入，乘以学好的Word Embedding矩阵Q，直接取出单词对应的Word Embedding</p>
<p>遗留下的问题：word2vec最大的缺陷是无法解决多义词问题，即如果将一个词对应的向量定下来后，即使出现其他语义情况也无法再改变。</p>
<h4 id="RNN（Recurrent-Neural-Network）"><a href="#RNN（Recurrent-Neural-Network）" class="headerlink" title="RNN（Recurrent Neural Network）"></a>RNN（Recurrent Neural Network）</h4><p><img src="D:\github\CDN\bg\pic\rnn.png" loading="lazy"></p>
<p>RNN：时序神经网络，拥有时间上的顺序性。能结合上下文考虑，弥补了全连接神经网络的不足。</p>
<p>遗留下的问题：会存在梯度消失，即模型难以学习到远距离的依赖关系。RNN 所谓梯度消失的真正含义是，梯度被近距离梯度主导，导致模型难以学到远距离的依赖关系。</p>
<h4 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h4><p><img src="D:\github\CDN\bg\pic\lstm.png" loading="lazy"></p>
<p>相比于原始的RNN的隐层(hidden state)， LSTM增加了一个细胞状态(cell state)。</p>
<p>遗留下的问题：表面上似乎没有什么问题了，但其实这个结合的方法是死板的，只结合前文而没有结合后文，依旧会出现考虑不全面的问题。</p>
<h4 id="Seq2Seq（Attention）"><a href="#Seq2Seq（Attention）" class="headerlink" title="Seq2Seq（Attention）"></a>Seq2Seq（Attention）</h4><p>RNN结构大多对序列的长度比较局限，对于类似于机器翻译的任务，输入和输出长度并不对等，为N to M的结构，简单的RNN束手无策，因此便有了新的模型，Encoder-Decoder模型，也就是Seq2Seq模型。</p>
<p>核心问题是当序列过长时，上述的Decoder输出的上下文向量 c 无法记住所有信息，会出现长序列梯度消失的问题。比如句子有100个词，那么c里面可能丢失了前几个词的信息。</p>
<p>Attention机制的Decoder结构如下：</p>
<p><img src="D:\github\CDN\bg\pic\attention.png" loading="lazy"></p>
<p>首先计算上一个神经元隐藏状态h与Encoder每一个神经元隐藏状态的相似度，计算使用某种相似度计算函数。<br>“集中注意力”。对以上相似度使用softmax函数，得到Encoder每个隐藏状态在处理第 t 个词的时候的“注意力” α。计算得到各个上下文向量：<br>$$<br>c_t = \sum_{i=1}^N\alpha_{ti}h_i<br>$$<br>后面Decoder对 y 的计算与Decoder（将前一个神经单元的输出作为当前神经单元的输出。）的计算方式几乎一致，区别就在于上下文向量 c 的变化。</p>
<p><strong>自注意力机制：</strong></p>
<p>假设当前有输入信息 H=[ℎ1,ℎ2,…,ℎn] ，我们需要使用自注意力机制获取每个位置的输出context=[context1,context2,…,contextn] 。</p>
<p><strong>首先</strong>，需要将原始输入映射到查询空间 Q、键空间 K 和值空间 V，相关计算公式如下：</p>
<p> Q=HW_q =[q_1,q_2,…,q_n] \ K=HW_k =[k_1,k_2,…,k_n]\ V=HW_v =[v_1,v_2,…,v_n]</p>
<p> <strong>接下来</strong>，我们将去计算每个位置的注意力分布，并且将相应结果进行加权求和：</p>
<p><img src="D:\github\CDN\bg\pic\qkv.png" loading="lazy"></p>
<p>其中 s(q_i,k_j) 是经过上述点积、缩放后分数值。</p>
<p><strong>最后</strong>，为了加快计算效率，这里其实可以使用矩阵计算的方式，一次性计算出所有位置的的Attention输出向量：</p>
<p><img src="D:\github\CDN\bg\pic\qkv1.png" loading="lazy"></p>
<h4 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h4><p>2017 年，Google 在论文 Attention is All you need 中提出了 Transformer 模型，其使用 Self-Attention 结构取代了在 NLP 任务中常用的 RNN 网络结构。Transformer 本质上是一个 Encoder-Decoder 架构。</p>
<p>编码组件由多层编码器（Encoder）组成（在论文中作者使用了 6 层编码器）。解码组件也是由相同层数的解码器（Decoder）组成（在论文也使用了 6 层）。</p>
<p>每个编码器由两个子层组成：Self-Attention 层（自注意力层）和 Position-wise Feed Forward Network（前馈网络，缩写为 FFN）。</p>
<p>解码器也有编码器中这两层，但是它们之间还有一个注意力层（即 Encoder-Decoder Attention），其用来帮忙解码器关注输入句子的相关部分（类似于 seq2seq 模型中的注意力）。</p>
<p>self-attention机制：scaled dot-product attention （缩放点积注意力）</p>
<p><img src="D:\github\CDN\bg\pic\scaled.png" loading="lazy"></p>
<p><strong>多头注意力机制（Multi-head Attention）</strong></p>
<p><img src="D:\github\CDN\bg\pic\multi.png" loading="lazy"></p>
<p>首先，通过 h hh 个不同的线性变换对 Query、Key 和 Value 进行映射；然后，将不同的 Attention 拼接起来；最后，再进行一次线性变换。每一组注意力用于将输入映射到不同的子表示空间，这使得模型可以在不同子表示空间中关注不同的位置。</p>
<p><img src="D:\github\CDN\bg\pic\concat.png" loading="lazy"></p>
<p>编码器结构中有一个需要注意的细节：每个编码器的每个子层（Self-Attention 层和 FFN 层）都有一个残差连接，再执行一个层标准化操作</p>
<p>**Mask **表示掩码，它对某些值进行掩盖，使其在参数更新时不产生效果。Transformer 模型里面涉及两种 mask，分别是 Padding Mask 和 Sequence Mask。其中，Padding Mask 在所有的 scaled dot-product attention 里面都需要用到，而 Sequence Mask 只有在 Decoder 的 Self-Attention 里面用到。</p>
<p>其中，Padding Mask，因为每个批次输入序列的长度是不一样的，所以我们要对输入序列进行对齐。具体来说，就是在较短的序列后面填充 0（但是如果输入的序列太长，则是截断，把多余的直接舍弃）。</p>
<p>具体的做法：把这些位置的值加上一个非常大的负数（负无穷），这样的话，经过 Softmax 后，这些位置的概率就会接近 0。</p>
<p>Sequence Mask 是为了使得 Decoder 不能看见未来的信息。也就是对于一个序列，在 t  时刻，我们的解码输出应该只能依赖于 t 时刻之前的输出，而不能依赖 t 之后的输出。因为我们需要想一个办法，把 t 之后的信息给隐藏起来。</p>
<p>具体的做法：产生一个上三角矩阵，上三角的值全为 0。把这个矩阵作用在每个序列上，就可以达到我们的目的。</p>
<p>解码器栈的输出是一个 float 向量。我们怎么把这个向量转换为一个词呢？通过一个线性层再加上一个 Softmax 层实现。线性层是一个简单的全连接神经网络，其将解码器栈的输出向量映射到一个更长的向量，这个向量被称为 logits 向量。现在假设我们的模型有 10000 个英文单词（模型的输出词汇表）。因此 logits 向量有 10000 个数字，每个数表示一个单词的分数。然后，Softmax 层会把这些分数转换为概率（把所有的分数转换为正数，并且加起来等于 1）。最后选择最高概率所对应的单词，作为这个时间步的输出。</p>
<p>在 Transformer 论文，提到一个细节：编码组件和解码组件中的嵌入层，以及最后的线性层共享权重矩阵。不过，在嵌入层中，会将这个共享权重矩阵乘以根号下d_model。</p>
<h4 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h4><p><img src="D:\github\CDN\bg\pic\bert.png" loading="lazy"></p>
<p>BERT的全称为Bidirectional Encoder Representation from Transformers，是一个预训练的语言表征模型。它强调了不再像以往一样采用传统的单向语言模型或者把两个单向语言模型进行浅层拼接的方法进行预训练，而是采用新的<strong>masked language model（MLM）</strong>，以致能生成<strong>深度的双向</strong>语言表征。</p>
<p>该模型有以下主要优点：</p>
<p>1）采用MLM对双向的Transformers进行预训练，以生成深层的双向语言表征。</p>
<p>2）预训练后，只需要添加一个额外的输出层进行fine-tune，就可以在各种各样的下游任务中取得state-of-the-art的表现。在这过程中并不需要对BERT进行任务特定的结构修改。</p>
<p>以往的预训练模型的结构会受到单向语言模型<em>（从左到右或者从右到左）</em>的限制，因而也限制了模型的表征能力，使其只能获取单方向的上下文信息。而BERT利用MLM进行预训练并且采用深层的双向Transformer组件<em>（单向的Transformer一般被称为Transformer decoder，其每一个token（符号）只会attend到目前往左的token。而双向的Transformer则被称为Transformer encoder，其每一个token会attend到所有的token。）</em>来构建整个模型，因此最终生成<strong>能融合左右上下文信息</strong>的深层双向语言表征。</p>
<p>作者还在输入的每一个序列开头都插入特定的<strong>分类token（[CLS]）</strong>，该分类token对应的最后一个Transformer层输出被用来起到聚集整个序列表征信息的作用。</p>
<p>由于BERT是一个预训练模型，其必须要适应各种各样的自然语言任务，因此模型所输入的序列必须有能力包含一句话<em>（文本情感分类，序列标注任务）</em>或者两句话以上<em>（文本摘要，自然语言推断，问答任务）</em>。那么如何令模型有能力去分辨哪个范围是属于句子A，哪个范围是属于句子B呢？BERT采用了两种方法去解决：</p>
<p>1）在序列tokens中把<strong>分割token（[SEP]）</strong>插入到每个句子后，以分开不同的句子tokens。</p>
<p>2）为每一个token表征都添加一个可学习的分割embedding来指示其属于句子A还是句子B。</p>
<p>BERT的输入为每一个token对应的表征，实际上该表征是由三部分组成的，分别是对应的<strong>token</strong>，<strong>分割</strong>和<strong>位置</strong> embeddings</p>
<p><img src="D:\github\CDN\bg\pic\emb.jpg" loading="lazy"></p>
<p><strong>C</strong>为分类token（[CLS]）对应最后一个Transformer的输出，T_i则代表其他token对应最后一个Transformer的输出。对于一些token级别的任务<em>（如，序列标注和问答任务）</em>，就把T_i 输入到额外的输出层中进行预测。对于一些句子级别的任务<em>（如，自然语言推断和情感分类任务）</em>，就把<strong>C</strong>输入到额外的输出层中，这里也就解释了为什么要在每一个token序列前都要插入特定的分类token。</p>
<p><strong>BERT预训练任务</strong></p>
<p>虽然NLP领域没有像ImageNet这样质量高的人工标注数据，但是可以利用大规模文本数据的<strong>自监督性质</strong>来构建预训练任务。因此BERT构建了两个预训练任务，分别是<strong>Masked Language Model</strong>和<strong>Next Sentence Prediction</strong>。</p>
<p><strong>MLM</strong></p>
<p>MLM是BERT能够不受单向语言模型所限制的原因。简单来说就是以15%的概率用mask token （[MASK]）随机地对每一个训练序列中的token进行替换，然后预测出[MASK]位置原有的单词。然而，由于[MASK]并不会出现在下游任务的微调（fine-tuning）阶段，因此预训练阶段和微调阶段之间产生了<strong>不匹配</strong>（这里很好解释，就是预训练的目标会令产生的语言表征对[MASK]敏感，但是却对其他token不敏感）。因此BERT采用了以下策略来解决这个问题：</p>
<p>首先在每一个训练序列中以15%的概率随机地选中某个token位置用于预测，假如是第i个token被选中，则会被替换成以下三个token之一</p>
<p>1）80%的时候是[MASK]。如，my dog is <strong>hairy</strong>——&gt;my dog is <strong>[MASK]</strong></p>
<p>2）10%的时候是随机的其他token。如，my dog is <strong>hairy</strong>——&gt;my dog is <strong>apple</strong></p>
<p>3）10%的时候是原来的token<em>（保持不变，个人认为是作为2）所对应的负类）</em>。如，my dog is <strong>hairy</strong>——&gt;my dog is <strong>hairy</strong></p>
<p><strong>NSP</strong></p>
<p>一些如问答、自然语言推断等任务需要理解两个句子之间的关系，而MLM任务倾向于抽取<strong>token层次</strong>的表征，因此不能直接获取<strong>句子层次</strong>的表征。为了使模型能够有能力理解句子间的关系，BERT使用了NSP任务来预训练，简单来说就是预测两个句子是否连在一起。具体的做法是：对于每一个训练样例，我们在语料库中挑选出句子A和句子B来组成，50%的时候句子B就是句子A的下一句<em>（标注为IsNext）</em>，剩下50%的时候句子B是语料库中的随机句子<em>（标注为NotNext）</em>。接下来把训练样例输入到BERT模型中，用[CLS]对应的C信息去进行二分类的预测。</p>
<p><strong>BERT预训练过程</strong></p>
<p>Bert的预训练主要包含两个任务，MLM和NSP，Masked Language Model任务可以理解为完形填空，随机mask每一个句子中15%的词，用其上下文来做预测；Next Sentence Prediction任务选择一些句子对A与B，其中50%的数据B是A的下一条句子，剩余50%的数据B是语料库中随机选择的，学习其中的相关性。BERT 预训练阶段实际上是将上述两个任务结合起来，同时进行，然后将所有的 Loss 相加</p>
<h3 id="LLM-Large-Language-Model"><a href="#LLM-Large-Language-Model" class="headerlink" title="LLM(Large Language Model)"></a>LLM(Large Language Model)</h3><h4 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h4><p>利用无标注文本进行学习仍存在两个待解决的问题：1.目前尚不清楚哪种类型的优化目标在学习文本表征方面最有效。当下有很多研究在不同的任务中用了不同的优化目标而达到最优；2.如何将学习到的文本表征用于下游任务也不明确。现有的方法一般是针对下游任务更改模型结构等；</p>
<p>本文提出一种半监督的方法GPT，用于自然语言理解任务，GPT的整体流程结合了无监督的预训练和有监督的微调。目标旨在学习到一种通用的表征能够以极小的代价用于各种下游任务。<strong>本质上GPT1是基于Transformer的Decoder（变体）开发的。</strong></p>
<p>训练过程整体上分为两步：1）在大规模文本数据上学习到一个高容量的语言模型；2）在标注数据上进行微调。</p>
<p><strong>Decoder的修改(相较于Transformer decoder)：</strong></p>
<p>1.Transformer Decoder：Masked multi-head self-attention + encoder-decoder multi-head self-attention +feed forward</p>
<p>2.GPT Decoder:Masked multi-head self-attention+ feed forward</p>
<p>一个通用的语言模型应该能够处理任何字符，但是现有的语言模型通过包含各种预处理操作：lower-casing,tokenization,预设词汇表等。这些操作都会限制语言模型能够处理的字符范围。GPT-2综合考虑了OOV问题和词表过大的问题，使用了BPE算法，也能够使模型处理任何字符。</p>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>尘渊</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://www.xiye7lai.github.io/2023/09/09/NLP/" title="NLP速成">https://www.xiye7lai.github.io/2023/09/09/NLP/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a class="post-nav-next" href="/2023/09/05/unlearn%20survey/" rel="next" title="MU servey 总结"><span class="post-nav-text">MU servey 总结</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>若您无 GitHub 账号，可直接在下方匿名评论。</span><br><span>若您想及时得到回复提醒，建议跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br><a class="hty-button hty-button--raised" id="github-issues" target="_blank" rel="noopener" href="https://github.com/xiye7lai/xiye7lai.github.io/issues?q=is:issue+NLP速成">GitHub Issues</a></div><div class="comment-container" id="valine-container"></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2023 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> ZJM</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v0.5.2</span></div><div class="live_time"><span>存在了</span><span id="display_live_time"></span><span class="moe-text">这么久哩</span><script>function blog_live_time() {
  window.setTimeout(blog_live_time, 1000);
  const start = new Date('2020-04-17T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div><div id="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-user-line"></use></svg></span><span id="busuanzi_value_site_uv"></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span></div><script defer src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function initValine() {
  new Valine(CONFIG.valine);
}
document.addEventListener("DOMContentLoaded", function() {
  initValine();
});</script></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#ff1493" stroke-width="2" stroke-linecap="round"></circle></svg></a></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script><script src="https://cdn.jsdelivr.net/npm/live2d-widget@^3.1.3/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"https://cdn.jsdelivr.net/npm/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true},"react":{"opacity":1},"dialog":{"enable":true,"hitokoto":true},"log":false});</script></body></html>